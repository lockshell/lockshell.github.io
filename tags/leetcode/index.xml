<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 络壳 LockShell</title>
    <link>https://lockshell.com/tags/leetcode/</link>
    <description>Recent content in leetcode on 络壳 LockShell</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 28 Mar 2015 16:51:47 +0800</lastBuildDate>
    
	<atom:link href="https://lockshell.com/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Leetcode-112-Path-Sum</title>
      <link>https://lockshell.com/2015/03/28/leetcode-112-path-sum/</link>
      <pubDate>Sat, 28 Mar 2015 16:51:47 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-112-path-sum/</guid>
      <description>112. Path Sum  Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
 Solution /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public static boolean isLeaf(TreeNode node){ if (node !</description>
    </item>
    
    <item>
      <title>[LeetCode][236]二叉树的最近公共祖先</title>
      <link>https://lockshell.com/2015/03/28/leetcode-236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Sat, 28 Mar 2015 16:36:31 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>236. Lowest Common Ancestor of a Binary Tree 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公</description>
    </item>
    
    <item>
      <title>[LeetCode][108]将排序数组转为二叉搜索树</title>
      <link>https://lockshell.com/2015/03/28/leetcode-108-convert-sorted-array-binary-tree/</link>
      <pubDate>Sat, 28 Mar 2015 16:36:07 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-108-convert-sorted-array-binary-tree/</guid>
      <description>108. Convert Sorted Array to Binary Search Tree 将排序数组转为二叉搜索树 Solution /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public static TreeNode solve(int low, int high, int[]nums){ if(low &amp;lt; 0 || high</description>
    </item>
    
    <item>
      <title>[LeetCode][113]二叉树中和为某一值的路径</title>
      <link>https://lockshell.com/2015/03/28/leetcode-113-path-sum-ii/</link>
      <pubDate>Sat, 28 Mar 2015 16:34:26 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-113-path-sum-ii/</guid>
      <description>113. Path Sum II 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结</description>
    </item>
    
    <item>
      <title>[LeetCode][104]二叉树的最大深度</title>
      <link>https://lockshell.com/2015/03/28/leetcode-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Sat, 28 Mar 2015 16:18:37 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-104-maximum-depth-of-binary-tree/</guid>
      <description>104. Maximum Depth of Binary Tree 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 Solution /**</description>
    </item>
    
    <item>
      <title>[LeetCode][110]判断二叉树是否平衡</title>
      <link>https://lockshell.com/2015/03/28/leetcode-110-balanced-binary-tree/</link>
      <pubDate>Sat, 28 Mar 2015 16:15:43 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-110-balanced-binary-tree/</guid>
      <description>110. Same Tree 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 Solution /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int height(TreeNode node) { if(node ==</description>
    </item>
    
    <item>
      <title>[LeetCode][102]二叉树层次遍历</title>
      <link>https://lockshell.com/2015/03/28/leetcode-102-binary-tree-level-order-traversal/</link>
      <pubDate>Sat, 28 Mar 2015 16:10:24 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-102-binary-tree-level-order-traversal/</guid>
      <description>102. Binary Tree Level Order Traversal 给定一个二叉树，返回其按层次遍历的节点值。 （即逐层地，从左到右访问所有节点）。 Solution /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int</description>
    </item>
    
    <item>
      <title>[LeetCode][98]判断二叉搜索树</title>
      <link>https://lockshell.com/2015/03/28/leetcode-98-validate-binary-search-tree/</link>
      <pubDate>Sat, 28 Mar 2015 15:24:11 +0800</pubDate>
      
      <guid>https://lockshell.com/2015/03/28/leetcode-98-validate-binary-search-tree/</guid>
      <description>98. Validate Binary Search Tree 请实现一个函数，检查一棵二叉树是否为二叉查找树。 给定树的根结点指针TreeNode* root，请返回一个bool，代表该树是否为二</description>
    </item>
    
  </channel>
</rss>